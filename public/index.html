<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Photo Slideshow</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #grid-container {
      display: grid;
      width: 100vw;
      height: 100vh;
      gap: 2px;
      background: #111;
    }

    .panel {
      position: relative;
      overflow: hidden;
      background: #000;
    }

    .panel .media-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity var(--transition-duration, 1.5s) ease-in-out;
    }

    .panel .media-wrapper.active {
      opacity: 1;
    }

    .panel .media-wrapper img,
    .panel .media-wrapper video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .panel .date-overlay {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 5px 12px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      opacity: 0;
      transition: opacity var(--transition-duration, 1.5s) ease-in-out;
      z-index: 10;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    .panel .date-overlay.active {
      opacity: 1;
    }

    .panel .loading-indicator {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      opacity: 0;
      z-index: 10;
      transition: opacity 0.2s ease-in-out;
    }

    .panel .loading-indicator.active {
      opacity: 1;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 24px;
      z-index: 100;
    }

    #loading.hidden {
      display: none;
    }

    /* Fullscreen button */
    #fullscreen-btn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      border-radius: 5px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    body:hover #fullscreen-btn {
      opacity: 1;
    }

    #fullscreen-btn:hover {
      background: rgba(0,0,0,0.8);
    }

    /* Login overlay */
    #login-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    #login-overlay.hidden {
      display: none;
    }

    #login-form {
      background: #1a1a1a;
      padding: 40px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }

    #login-form h2 {
      color: #fff;
      margin-bottom: 20px;
      font-weight: 400;
    }

    #login-form input {
      width: 250px;
      padding: 12px 15px;
      border: 1px solid #333;
      border-radius: 5px;
      background: #222;
      color: #fff;
      font-size: 16px;
      margin-bottom: 15px;
    }

    #login-form input:focus {
      outline: none;
      border-color: #666;
    }

    #login-form button {
      width: 250px;
      padding: 12px 15px;
      border: none;
      border-radius: 5px;
      background: #3a7bd5;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }

    #login-form button:hover {
      background: #2a6bc5;
    }

    #login-error {
      color: #e74c3c;
      margin-top: 10px;
      font-size: 14px;
    }

    #login-error.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="login-overlay" class="hidden">
    <div id="login-form">
      <h2>üñºÔ∏è Photo Slideshow</h2>
      <input type="password" id="password-input" placeholder="Enter password" autofocus>
      <button onclick="submitLogin()">Login</button>
      <div id="login-error" class="hidden">Invalid password</div>
    </div>
  </div>
  <div id="loading">Loading slideshow...</div>
  <button id="fullscreen-btn" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
  <div id="grid-container"></div>

  <script>
    let settings = {};
    let mediaFiles = [];
    let panels = [];
    
    // Global tracking for unique image display
    let currentlyDisplayed = new Set(); // Images currently shown in any panel
    let globalUsedMedia = new Set();    // All images shown in current cycle
    let availableQueue = [];            // Shuffled queue of available images
    
    const MONTH_NAMES = {
      en: [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ],
      de: [
        'Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
        'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'
      ],
      es: [
        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
        'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
      ],
      fr: [
        'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
        'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'
      ],
      it: [
        'Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno',
        'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'
      ]
    };

    let sessionId = localStorage.getItem('slideshow_session');

    // Add session header to all fetch requests
    async function authFetch(url, options = {}) {
      const headers = { ...options.headers };
      if (sessionId) {
        headers['X-Session-Id'] = sessionId;
      }
      return fetch(url, { ...options, headers });
    }

    async function checkAuth() {
      const res = await authFetch('/api/auth/status');
      const status = await res.json();
      
      if (status.passwordRequired && !status.authenticated) {
        document.getElementById('login-overlay').classList.remove('hidden');
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('password-input').focus();
        return false;
      }
      return true;
    }

    async function submitLogin() {
      const password = document.getElementById('password-input').value;
      const errorEl = document.getElementById('login-error');
      
      try {
        const res = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password })
        });
        
        const result = await res.json();
        
        if (result.success) {
          sessionId = result.sessionId;
          if (sessionId) {
            localStorage.setItem('slideshow_session', sessionId);
          }
          document.getElementById('login-overlay').classList.add('hidden');
          document.getElementById('loading').classList.remove('hidden');
          init();
        } else {
          errorEl.classList.remove('hidden');
          document.getElementById('password-input').value = '';
          document.getElementById('password-input').focus();
        }
      } catch (err) {
        errorEl.classList.remove('hidden');
      }
    }

    // Handle Enter key on password input
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('password-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          submitLogin();
        }
      });
    });

    async function init() {
      try {
        // Check authentication first
        if (!(await checkAuth())) {
          return;
        }

        // Load settings
        const settingsRes = await authFetch('/api/settings');
        if (settingsRes.status === 401) {
          sessionId = null;
          localStorage.removeItem('slideshow_session');
          checkAuth();
          return;
        }
        settings = await settingsRes.json();

        // Set CSS transition duration
        document.documentElement.style.setProperty('--transition-duration', `${settings.transitionDuration}s`);

        // Load media files
        const mediaRes = await authFetch('/api/media');
        mediaFiles = await mediaRes.json();

        if (mediaFiles.length === 0) {
          document.getElementById('loading').textContent = 'No photos found in the photos folder';
          return;
        }

        // Setup grid
        setupGrid();

        // Hide loading
        document.getElementById('loading').classList.add('hidden');

      } catch (err) {
        console.error('Error initializing:', err);
        document.getElementById('loading').textContent = 'Error loading slideshow';
      }
    }

    function setupGrid() {
      const container = document.getElementById('grid-container');
      container.style.gridTemplateColumns = `repeat(${settings.gridColumns}, 1fr)`;
      container.style.gridTemplateRows = `repeat(${settings.gridRows}, 1fr)`;

      const totalPanels = settings.gridColumns * settings.gridRows;

      // Initialize the available queue with shuffled media
      availableQueue = [...mediaFiles].sort(() => Math.random() - 0.5);
      currentlyDisplayed.clear();
      globalUsedMedia.clear();

      for (let i = 0; i < totalPanels; i++) {
        const panel = createPanel(i);
        container.appendChild(panel.element);
        panels.push(panel);

        // Get unique initial media from the queue
        let initialMedia;
        if (availableQueue.length > 0) {
          initialMedia = availableQueue.shift();
        } else {
          // More panels than images - reset queue but allow temporary duplicates for init
          availableQueue = [...mediaFiles].sort(() => Math.random() - 0.5);
          initialMedia = availableQueue.shift();
        }
        
        showMedia(panel, initialMedia);

        // Start random timer for this panel
        scheduleNextChange(panel);
      }
    }

    function createPanel(index) {
      const element = document.createElement('div');
      element.className = 'panel';
      element.dataset.index = index;

      // Create two media wrappers for crossfade effect
      const wrapper1 = document.createElement('div');
      wrapper1.className = 'media-wrapper';
      
      const wrapper2 = document.createElement('div');
      wrapper2.className = 'media-wrapper';

      // Create date overlays
      const dateOverlay1 = document.createElement('div');
      dateOverlay1.className = 'date-overlay';
      
      const dateOverlay2 = document.createElement('div');
      dateOverlay2.className = 'date-overlay';

      // Create loading indicator
      const loadingIndicator = document.createElement('div');
      loadingIndicator.className = 'loading-indicator';

      element.appendChild(wrapper1);
      element.appendChild(wrapper2);
      element.appendChild(dateOverlay1);
      element.appendChild(dateOverlay2);
      element.appendChild(loadingIndicator);

      return {
        element,
        wrappers: [wrapper1, wrapper2],
        dateOverlays: [dateOverlay1, dateOverlay2],
        loadingIndicator,
        activeIndex: 0,
        currentMedia: null,
        preloadedMedia: null,
        preloadedElement: null
      };
    }

    // Initialize or reset the available queue with shuffled unused media
    function resetAvailableQueue() {
      // Get all media that hasn't been used in this cycle
      const unused = mediaFiles.filter(m => !globalUsedMedia.has(m.path));
      
      if (unused.length === 0) {
        // All media has been shown, start a new cycle
        globalUsedMedia.clear();
        availableQueue = [...mediaFiles].sort(() => Math.random() - 0.5);
      } else {
        availableQueue = unused.sort(() => Math.random() - 0.5);
      }
    }

    function getRandomMedia(panel) {
      // Remove current panel's media from currently displayed (it's about to change)
      if (panel.currentMedia) {
        currentlyDisplayed.delete(panel.currentMedia.path);
      }

      // Filter out media currently shown in other panels
      let available = availableQueue.filter(m => !currentlyDisplayed.has(m.path));
      
      // If queue is empty or all available are currently displayed, reset queue
      if (available.length === 0) {
        resetAvailableQueue();
        available = availableQueue.filter(m => !currentlyDisplayed.has(m.path));
      }
      
      // If still no available (edge case: more panels than media), allow duplicates
      if (available.length === 0) {
        available = mediaFiles.filter(m => m !== panel.currentMedia);
        if (available.length === 0) {
          available = mediaFiles;
        }
      }

      // Pick the first available (queue is already shuffled)
      const selected = available[0];
      
      // Remove from queue and mark as used
      const queueIndex = availableQueue.findIndex(m => m.path === selected.path);
      if (queueIndex > -1) {
        availableQueue.splice(queueIndex, 1);
      }
      
      return selected;
    }

    function formatDate(dateInfo) {
      if (!dateInfo) return '';
      const lang = settings.language || 'en';
      const months = MONTH_NAMES[lang] || MONTH_NAMES.en;
      const monthName = months[dateInfo.month - 1] || '';
      return `${monthName} ${dateInfo.year}`;
    }

    // Preload media and return a promise
    function preloadMedia(media) {
      return new Promise((resolve) => {
        if (media.isVideo) {
          const video = document.createElement('video');
          video.muted = true;
          video.loop = true;
          video.playsInline = true;
          video.preload = 'auto';
          video.oncanplaythrough = () => resolve(video);
          video.onerror = () => resolve(video); // Resolve anyway to not block
          video.src = media.path;
        } else {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => resolve(img); // Resolve anyway to not block
          img.src = media.path;
        }
      });
    }

    // Preload next media for a panel
    async function preloadNextForPanel(panel) {
      panel.loadingIndicator.classList.add('active');
      const nextMedia = getRandomMedia(panel);
      panel.preloadedMedia = nextMedia;
      panel.preloadedElement = await preloadMedia(nextMedia);
      panel.loadingIndicator.classList.remove('active');
    }

    function showMedia(panel, media, preloadedElement = null) {
      const nextIndex = 1 - panel.activeIndex;
      const currentWrapper = panel.wrappers[panel.activeIndex];
      const nextWrapper = panel.wrappers[nextIndex];
      const currentDateOverlay = panel.dateOverlays[panel.activeIndex];
      const nextDateOverlay = panel.dateOverlays[nextIndex];

      // Clear next wrapper
      nextWrapper.innerHTML = '';

      // Use preloaded element or create new one
      let mediaElement;
      if (preloadedElement) {
        mediaElement = preloadedElement;
        if (media.isVideo) {
          mediaElement.autoplay = true;
          mediaElement.play().catch(() => {}); // Ignore autoplay errors
        }
      } else if (media.isVideo) {
        mediaElement = document.createElement('video');
        mediaElement.src = media.path;
        mediaElement.muted = true;
        mediaElement.loop = true;
        mediaElement.autoplay = true;
        mediaElement.playsInline = true;
      } else {
        mediaElement = document.createElement('img');
        mediaElement.src = media.path;
        mediaElement.loading = 'eager';
      }

      nextWrapper.appendChild(mediaElement);

      // Set date overlay
      const dateText = formatDate(media.date);
      nextDateOverlay.textContent = dateText;

      // Crossfade
      currentWrapper.classList.remove('active');
      nextWrapper.classList.add('active');
      currentDateOverlay.classList.remove('active');
      if (dateText) {
        nextDateOverlay.classList.add('active');
      }

      // Update panel state
      panel.activeIndex = nextIndex;
      panel.currentMedia = media;
      currentlyDisplayed.add(media.path);  // Track globally displayed
      globalUsedMedia.add(media.path);     // Track in current cycle
      panel.preloadedMedia = null;
      panel.preloadedElement = null;
    }

    async function scheduleNextChange(panel) {
      const delay = getRandomDuration();
      
      // Start preloading after half the delay
      const preloadDelay = Math.max(delay / 2, 2000);
      
      setTimeout(() => {
        preloadNextForPanel(panel);
      }, preloadDelay);
      
      setTimeout(() => {
        // Use preloaded media if available
        if (panel.preloadedMedia && panel.preloadedElement) {
          showMedia(panel, panel.preloadedMedia, panel.preloadedElement);
        } else {
          // Fallback: show without preload
          const nextMedia = getRandomMedia(panel);
          showMedia(panel, nextMedia);
        }
        scheduleNextChange(panel);
      }, delay);
    }

    function getRandomDuration() {
      const min = settings.minDuration * 1000;
      const max = settings.maxDuration * 1000;
      return Math.random() * (max - min) + min;
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    // Handle keyboard
    document.addEventListener('keydown', (e) => {
      if (e.key === 'f' || e.key === 'F') {
        toggleFullscreen();
      }
      if (e.key === 'Escape' && document.fullscreenElement) {
        document.exitFullscreen();
      }
    });

    // Initialize on load
    window.addEventListener('load', init);
  </script>
</body>
</html>
